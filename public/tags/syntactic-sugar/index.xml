<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Syntactic sugar - Tag - LexusLee&#39;s blog</title>
        <link>https://example.com/tags/syntactic-sugar/</link>
        <description>Syntactic sugar - Tag - LexusLee&#39;s blog</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><managingEditor>lexuscyborg103@gmail.com (LexusLee)</managingEditor>
            <webMaster>lexuscyborg103@gmail.com (LexusLee)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Mon, 07 Dec 2015 14:12:24 &#43;0800</lastBuildDate><atom:link href="https://example.com/tags/syntactic-sugar/" rel="self" type="application/rss+xml" /><item>
    <title>深入理解 Python 装饰器</title>
    <link>https://example.com/python-decorator-learning/</link>
    <pubDate>Mon, 07 Dec 2015 14:12:24 &#43;0800</pubDate>
    <author>Author</author>
    <guid>https://example.com/python-decorator-learning/</guid>
    <description><![CDATA[<p>最近在写 Python+Django 的时候发现，有时候封装 API 的时候经常会遗失一些重复的装饰信息，但是直接封装到方法里是比较差劲的写法，因为有多个模块可能同时需要这些装饰信息，所以我希望使用一种可以迭代的装饰器。于是我在 <a href="http://stackoverflow.com/questions/739654/how-can-i-make-a-chain-of-function-decorators-in-python/1594484#1594484" target="_blank" rel="noopener noreffer">Stack Overflow</a> 上找到了相应的解答。下面以这篇解答为引写下我理解 Python decorator 的思路过程。</p>]]></description>
</item></channel>
</rss>
